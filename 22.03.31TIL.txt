클래스
기본
    객체를 손쉽게 만들 수 있는 템플릿(ES6 부터 지원)
    구조
    class Fruit {
    constructor(name, emoji) {
        this.name = name;
        this.emoji = emoji;
    }

    display = () => {
        console.log(`${this.name}: ${this.emoji}`);
    };
    }
        생성자: new 키워드로 객체를 생성할때 호출되는 함수
            새로 찍어낼 객체의 내용이 여기 들어간다.    
        함수를 정의할 때 클래스내에선 function 붙이지 않는다.
        화살표 함수는 가능, this도 붙이지 않는다.
        보통 생성자 밖에서 함수를 정의한다.
    인스턴스
        const apple = new Fruit()
        apple이 Fruit 클래스의 인스턴스가 된다(복제품)
        인스턴스는 막다뤄도 문제가 되지 않는다.
        하지만 클래스는 막다루면 ㅈ된다.

static
    클래스 레벨 : 인스턴스에서는 접근하지 못하는 영역(원본 보호를 위해 사용)
    인스턴스 레벨 : 인스턴스에서 접근 가능한 영역
    변수나 함수 앞에 static을 붙이면 클래스 레벨이 된다.
    클래스 레벨의 메서드에서는 this를 참조할 수 없다.
   
  // 클래스 레벨의 메서드
    static makeRandomFruit() {
    // 클래스 레벨의 메서드에서는 this를 참조할 수 없음
    return new Fruit('banana', '🍌');
    }
    이건 왜 이렇게 한걸까?

필드
    접근제어자 : 한번 만들어놓은 인스턴스를 변경하지 못하게 하는 역할
    자바의 private과 굉장히 비슷하다.
    생성자를 선언하기 전 변수 앞에 #을 붙이면 된다.
    
getter
    접근자 프로퍼티 GET, SET
    함수를 변수(프로퍼티)화 해주는 친구들
    get : 프로퍼티를 나열해야 할 때 사용하는 접근자 프로퍼티
    set : 값을 할당할 때 사용하는 접근자 프로퍼티

extends
    상속, extends명령어를 이용해 부모클래스를 상속 받을 수 있다.
    왜 상속?
    큰 줄기를 공유하면서 세부적인 내용을 디테일하게 바꾸려면 상속을 이용하는게 편하다.
    부모 클래스의 기능을 그대로 사용하고 싶다면 super.메서드 or 변수를 사용하면 된다.

example 1,2
    1 : 카운터 만들기 잘 안되는 부분
        - 에러처리 x, private필드 사용 x, 메서드 이름선정 적절치 못함, getter 사용 x
    
    2 : 급여계산 잘 안되는 부분
        - 모든 프로퍼티를 똑같이 생성자에 적어주면 된다.
        궁금한 점 
        -왜 영상에서는 super(prop1,prop2,....)로 해결을 했을까?
